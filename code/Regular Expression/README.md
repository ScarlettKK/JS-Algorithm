# 工作中使用到的正则表达式总结

正则表达式，又称规则表达式，通常被用来[检索]、[替换]那些符合某个规则(模式)的字符串。

## JS正则表达式 基本语法

`/正则表达式主体/修饰符(可选)`

```javascript
var patt = /runoob/i
```

	/runoob/i  整体是一个正则表达式。

	runoob  是一个正则表达式主体 (用于检索)。

	i  是一个修饰符 (用于规定匹配规则)。

## 修饰符

用于规定匹配规则

	i 执行 对大小写不敏感 的匹配

	g 执行 全局 匹配（查找所有匹配而非在找到第一个匹配后停止）

	m 执行 多行 匹配 (将每一行都当成独立的一段进行匹配)

	默认匹配模式: 单行 非全局 对大小写敏感

代码示例:

```javascript
// 默认匹配模式: 非全局 对大小写敏感
var s = '1a31a\n4561a\n7891a\n1a1\n41a'
s.replace(/1A/, 'b')
// 输出: "1a31a
//       4561a
//       7891a
//       1a1
//       41a"
// 结果什么都没匹配出来...
```

```javascript
// i 执行 对大小写不敏感 的匹配
var s = '1a31a\n4561a\n7891a\n1a1\n41a'
s.replace(/1A/i, 'b')
// 输出: "b31a
//       4561a
//       7891a
//       1a1
//       41a"
// 第一个“1a”被匹配出来, 换成了'b'
```

```javascript
// g 执行 全局 匹配（查找所有匹配而非在找到第一个匹配后停止）
var s = '1a31a\n4561a\n7891a\n1a1\n41a'
s.replace(/1a/g, 'b')
// 输出: "b3b
//       456b
//       789b
//       b1
//       4b"
// 看到这里大家可能会疑惑, 怎么字符串中其实有换行, 但g也匹配了换行后的结果呢?

// 此时我们来转变一下:
var s = '1a31a\n4561a\n7891a\n1a1\n41a'
s.replace(/^1a/g, 'b')
// 输出: "b31a
//       4561a
//       7891a
//       1a1
//       41a"
// 这里我们是要匹配所有以“1a”开头的字符串
// 因为这里的修饰符没有m(多行匹配)
// 所以这里整段字符串会被当成一个字符串来匹配
// 字符串s的开头就是1a, 被替换成b, 替换结束

// 再举个例子:
var s = '4561a\n7891a\n1a1\n41a'
s.replace(/^1a/g, 'b')
// 这里什么都不会匹配出来, 因为这里整段字符串不以“1a”开头
```

修饰符g使用总结:
	
	所以g是全局匹配的意思, 也就是当我们的目的是匹配单纯的一段字符串(不管它是开头还是结尾)的时候, 
	它是会对全局进行搜索匹配的, 不管有没有换行

	而当我们的目的是匹配“以xx开头的字符串”的时候, g会把整段字符串当成一个整体来看待, 
	那么只会检测整体的开头是不是以xx开头, 并不会检测其中某一段的开头是不是xx

```javascript
// m 执行 多行 匹配 (将每一行都当成独立的一段进行匹配)
var s = '4561a\n7891a\n1a1\n41a'
s.replace(/^1a/m, 'b')
// 输出: "4561a
//	 7891a
//	 b1
//	 41a"
// 这里检测到第3段的开头是“1a”, 于是执行了替换
// m会把由换行符分开的每一段字符串当成独立的一个子字符串来看待, 这里会检测是否有一段子字符串以xx开头

// 修饰符m 通常会跟 修饰符g 一同搭配使用, 效果如下:
var s = '1a31a\n4561a\n7891a\n1a1\n41a'
s.replace(/^1a/gm, 'b')
// 输出: "b31a
//	 4561a
//	 7891a
//	 b1
//	 41a"
// 这里检测到1、4两段都以“1a”开头, 配合g进行了全局匹配与替换
```

修饰符m使用总结:

	/m代表多行模式multiline，如果目标字符串中不含有换行符\n，即只有一行，那么/m修饰符没有任何意义。

	如果正则表达式中不含有^或$匹配字符串的开头或结尾，那么/m修饰符没有任何意义。

	也就是说只有当目标字符串含有\n，而且正则表达式中含有^或$的时候，/m修饰符才有作用。

[注意事项]

我们需要注意字符串中的空格, 因为这会影响我们匹配的结果, 如:

```javascript
var s = '4561a\n7891a\n1a1\n41a'

// 与

var s = '4561a\n 7891a\n 1a1\n 41a'

// 的 s.replace(/^1a/gm, 'b') 匹配结果是不同的
// 第一个s是可以匹配到结果的,并能够进行replace
// 而第二个s匹配不到任何结果,因为后面几段字符串的开头是“ 1a”而不是“1a”
// 下面两段字符串同理

var s = `4561a
7891a
1a1
41a`

var s = `4561a
	 7891a
	 1a1
	 41a`

// 我们需要在正则表达式编程中注意这点
```

## 正则表达式主体语法

正则表达式直接量也被定义为包含在一对斜杠(/)之间的字符.所以,JavaScript可能会包含如下的代码:

```javascript
var pattern = /s$/;
```

### 开头结尾

`^`匹配一个输入或一行的开头，也就是必须以^之后的字符串开头, 如`/^a`/匹配"an A"，而不匹配"An a" 

`$` 匹配一个输入或一行的结尾，也就是必须以$之前的字符串结尾,`/a$/`匹配"An a"，而不匹配"an A" 

### 重复字符串

`*` 匹配前面元字符0次或多次，`/ba*/`将匹配b,ba,baa,baaa...

`+` 匹配前面元字符1次或多次，`/ba+/`将匹配ba,baa,baaa...

`?` 匹配前面元字符0次或1次，`/ba?/`将匹配b或ba 

### 字符集

`(x)` ()可以标记一个子表达式(子字符串)x的开始和结束位置, 并且在JS replace函数中, ()还可以起到匹配x, 并且将保存x在名为$1...$9的变量中的作用 

```javascript
name = "Doe, John";
name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");
// 输出"John Doe"
```

`x|y` 匹配x或y 

`{n}` 精确匹配n次 

`{n,}` 匹配n次以上 

`{n,m}` 匹配n-m次 

`[xyz]` 字符集(character set)，匹配这个集合中的任一一个字符(或元字符) 

`[^xyz]` 不匹配这个集合中的任何一个字符 

`[\b]` 匹配一个退格符 

### 特殊字符

`\` 做为转义，即通常在"\"后面的字符不按原来意义解释，如`/b/`匹配字符"b"，当b前面加了反斜杆后`/\b/`，转义为匹配一个单词的边界。

`\` 也可以作为正则表达式功能字符的还原，如"*"意为匹配它前面的元字符0次或多次，`/a*/`将匹配a,aa,aaa，加了"\"后，`/a\*/`将只匹配"a*"。

`\w` 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\w]匹配"$5.98"中的5，相当于[a-zA-Z0-9] 

`\W` 匹配一个不可以组成单词的字符，如[\W]匹配"$5.98"中的$，相当于[^a-zA-Z0-9]。 

`\d` 匹配一个字数字符，/\d/ = /[0-9]/ 

`\D` 匹配一个非字数字符，/\D/ = /[^0-9]/ 

`\b` 匹配一个单词的边界 

`\B` 匹配一个单词的非边界 

	什么是单词边界?

	接下来我们来举一个例子:

	我们的正则目标如下: 匹配字符串“magic”

```javascript
	var s = "welcome to nowamagic this magic place!"
    var regex = /(magic)/g;
    s.replace(regex, 'cat')
    // 匹配结果: "welcome to nowacat this cat place!"
```

	但是，通常情况下，我们只希望匹配 magic ，而不希望匹配 nowamagic 中出现的 magic。

	正则表达式中，可以在 字符 前加“\b”，来匹配 以 正则表达式中“\b”后面所跟的的字符 开头的 字符。

```javascript
	var s = "welcome to nowamagic this magic place!"
	var regex2 = /\b(magic)/g;
	s.replace(regex2, 'cat')
	// 匹配结果: "welcome to nowamagic this cat place!"
```

	正则表达式中，可以在 字符 后加“\b”，来匹配 以 正则表达式中“\b”前面所跟的的字符 结尾的 字符。

	如\bmagic\b，这个正则匹配，必须以m开头，以c为结尾, 内容为magic的字子符串, 且这个子字符串两头都必须是空格, 意为与其他单词区别分开。

	由上面我们可以看到, 单词边界类似于一个英文单词的开头结尾的空格, 有\b的位置就必须是一个空格, 如\bmagic只能匹配" magic"而不能匹配"xmagic"

`\cX` 这里的X代表一个控制符，如/\cM/匹配Ctrl-M 

`\n` 匹配一个换行符 

`\r` 匹配一个回车符 

`\t` 匹配一个制表符 

`\v` 匹配一个重直制表符 

`\s` 匹配一个空白字符，包括\n,\r,\f,\t,\v等 

`\S` 匹配一个非空白字符，等于/[^\n\f\r\t\v]/ 

## JS中的正则应用

### RegExp 对象

在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。

RegExp对象具有以下属性和方法:

<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6xp1zhihlj318a0u0tdo.jpg">

exec() 方法 用于检索字符串中的正则表达式的匹配

test() 方法 用于检测一个字符串是否匹配某个模式

### 应用正则的字符串方法

在 JavaScript 中，正则表达式可以应用于以下几个字符串方法 : search()、replace()、split()、match()

search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。

replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

```javascript
	// 将string内含有arr中任一字符串的部分,标记成为高亮
	reg = new RegExp('(' + arr.join('|') + ')', 'g')
	string = string.replace(reg, '<span style="color:red">$&</span>')
```

split() 方法 用于把一个字符串分割成字符串数组。

```javascript
	// 将字符串以|或者;分开
	string.split(/[|;]/)

	// 将字符串以||分开
	string.split(/\|{2}/)
```

match() 方法 可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。


















